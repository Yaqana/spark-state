/**
 * Copyright (c) Facebook, Inc. and its affiliates. 
 */

const Multipeer = require('Multipeer')
const Participants = require('Participants')
const SparkAutomergeWrapper = require('./spark_automerge_wrapper')
const Time = require('Time')

/**
 * Sends the update message generated by automerge through the given channel
 */
function sendUpdateMessages(state, syncStates, myParticipantId, channel) {
  const syncMessages = SparkAutomergeWrapper.generateSyncMessages(state, syncStates, myParticipantId)
  syncMessages.forEach(msg => channel.sendMessage(msg))
}

export async function createGlobalSignal(signal, startValue, signalName, guaranteeStateKey, updateState) {
  const channel = Multipeer.getBinaryMessageChannel(signalName)
  const myParticipantId = (await Participants.self).id
  let state = SparkAutomergeWrapper.init()

  const allPeers = await Participants.getAllOtherParticipants()
  const syncStates = {}

  for (const peer of allPeers) {
    SparkAutomergeWrapper.initPeerSyncState(syncStates, peer.id)
    peer.isActiveInSameEffect.monitor().subscribe(function (event) {
      const isLatestActive = event.newVal
      if (!isLatestActive) {
        SparkAutomergeWrapper.initPeerSyncState(syncStates, peer.id)
      }
    })
  }

  let delayTimer;
  let lastDelayTime = null;
  channel.onMessage.subscribe((msg) => {
    const [nextBackend, patch, ignoreMessage] = SparkAutomergeWrapper.processMessage(state, syncStates, myParticipantId, msg)
    if (ignoreMessage) {
      return
    }
    state = nextBackend

    if (patch) {
      const newValue = SparkAutomergeWrapper.get(state, signalName)
      if (signal.pinLastValue() !== newValue) {
        signal.setValueOnly(newValue)
      }
    }

    // Delay the message passing when value is updated from the network
    // This is to prevent each node sending too many messages at one time.
    // Otherwise all ack and sync messages are duplicated and storming the network
    if (delayTimer) {
      delayTimer.unsubscribe();
    }

    const currentTime = Date.now();
    if (lastDelayTime === null) {
      lastDelayTime = currentTime;
    }

    if (currentTime - lastDelayTime > 2000) {
      // Send update messages immediately if it has been delayed for more than 2 seconds
      sendUpdateMessages(state, syncStates, myParticipantId, channel);
      lastDelayTime = null;
    } else {
      // Schedule the update messages to be sent 100ms later.
      // This is to reduce the number of update messages responding to other peers' sync messages
      delayTimer = Time.setTimeout(() => {
        sendUpdateMessages(state, syncStates, myParticipantId, channel);
        lastDelayTime = null;
      }, 100);
    }
  })

  signal.updateState = function (event) {
    state = guaranteeStateKey(state, signalName, startValue)
    state = updateState(state, signalName, event)
    sendUpdateMessages(state, syncStates, myParticipantId, channel)
  };

  sendUpdateMessages(state, syncStates, myParticipantId, channel)

  signal.getName = () => signalName
}
